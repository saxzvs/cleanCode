# 5회차. 11, 12장 TIL

담당자: Jieun Ryu
상태: 완료

**TIL (Today I Learned)**

2022.05.19

**오늘 읽은 범위**

11장. 시스템 / 12장. 창발성

**책에서 기억하고 싶은 내용을 써보세요.**

- 11장. 시스템
    - 분리하기: 시스템 제작 / 시스템 사용은 아주 다르다.
        - 준비 과정과 런타임을 분리하기.
            - 준비 과정? 애플리케이션 객체를 제작하고 의존성을 서로 ‘연결’하는 작업
            - 런타임? 준비과정 이후에 이어지는 로직
        - 관심사 분리 : 애플리케이션 시작 단계를 분리하기!
            
            → 시작 단계/준비 과정/런타임 코드를 한데 뭉쳐 코드를 줄줄이 써내려가지 말고, 
            단계에 맞는 관심사로 분리할 것.
            
        - 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.
            
            → “좀스럽고 손쉬운” 기법으로 모듈성을 깨지 말자. 코드의 일관성을 늘 생각하기.
            
    
    ---
    
    1. 메인 분리
        1. 생성과 관련된 코드는 main or main 호출모듈로 옮기고,
        나머지 시스템은 모두 객체생성 및 모든 의존성이 연결된 것으로 가정하기.
        어플리케이션은 메인이나 객체 생성 과정을 전혀 모르게 “분리” 한다.
    2. factory 활용 → ABSTRACT FACTORY pattern
        1. 어플리케이션은 “생성 시점” 만 통제. 생성방법은 여전히 모름
    3. 의존성 주입, Dependency Injection
        1. 제어역전 기법을 의존성 관리에 적용한 매커니즘으로,
        클래스는 완전히 수동적 (객체생성 책임이 없으며, 의존성을 해결하지 않는다.)
        → 이러한 책임을 전담 매커니즘 (=DI 컨테이너) 에 일임한다.
        DI 컨테이너는 객체생성 및 그와 관련된 초기화 지연 영역도 함께 담당한다. 
    
    ---
    
    - 시스템 확장 : SW 시스템은 물리적 시스템과 다르다. 관심사를 적절히 분리해 관리할 수 있다면, SW architecture는 점진적으로 발전할 수 있다.
        - EBJ2 컨테이너는 관심사 분리가 어려웠다. 비즈니스 논리에 매우 강하게 결합된다. 
        (=런타임 코드에 강하게 결합된다고 이해함.)
        - 따라서, 해당 코드를 프레임워크 밖에서 재사용하기란 거의 불가능함.
        
        ⇒ 관점지향 프로그래밍 & 횡단 관심사 개념의 시작
        
        → 횡단 관심사: 영속성, 보안, 트랙잭션 같은 관심사는 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다는 관점에서 출발한 개념. 영속성 프레임웍을 모듈화하여 관리하고, 이는 관점지향 프로그래밍의 출발점이 된다.
        
        → 관점지향 프로그래밍: 특정 관심사를 지원하려면, 시스템에서 특정 지점들이 동작하는 방식에 일관성이 필요. 횡단 관심사에 모듈성을 확보하는 방법론.
        
    - AOP, 관점지향 프로그래밍
        - 자바 프록시
            - 개별 객체나 클래스에서 메소드 호출을 감쌀 때 사용함. (단순한 상황에 적합)
            - JDK에서 지원하는 동적 클래스 → interface만 지원함!
            - 클래스 프록시 → CGLIB, ASM, Javassist 등의 바이트코드 처리 라이브러리 필요.
            - 단점
            1) 코드의 양과 크기가 비대해진다. == 클린코드 작성의 한계 
            2) 시스템 단위 실행지점 명시 불가.
            - 주의: dispatch, proxy 등 AOP 구현기법과 AOP 자체를 혼동하기 쉽다.
            AOP란, 시스템 동작을 간결하고 모듈화된 방식으로 명시하는 능력 그 자체를 말한다.
        - 순수 자바 AOP 프레임워크 → ex) Spring bean
            - 대부분의 자바 프레임워크는 내부적으로 프록시를 사용한다.
            개발자가 설정파일 or API를 이용해 횡단 관심사를 포함한 어플리케이션의 기반구조를 확립하면, 프레임워크는 사용자가 모르게 프록시 or 바이트코드 라이브러리를 사용해 이를 구현한다.
        - Aspect J
            - 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장.
        - 테스트 주도 시스템 아키텍처 구축
            - 코드 수준에서 아키텍처 관심사가 분리되면, 테스트 주도 아키텍처 구축이 가능해진다.
        - 그 외 > 의사결정 최적화, 목적에 맞는 표준 사용하기, 도메인 특화 언어
    
- 12장. 창발성
    
    : Emergency Creativity.
    = 작은 결합들이 모여 복잡한 결과를 만들어내는 것.
    
    1. 모든 테스트를 실행한다.
    2. 중복을 없앤다.
    3. 프로그래머의 의도를 표현한다.
    4. 클래스와 메서드 수를 최소로 줄인다.
    
    ---
    
    - 모든 테스트 실행하기
        
        : 철저한 테스트가 가능하다 == 더 나은 설계를 얻을 수 있다.
        
        - 결합도가 높으면 테스트케이스를 작성하기도 어렵다.
        TC가 많아질수록, 개발자는 DIP / DI / Interface / Abstract 등의 도구로 결합도를 낮출 수밖에 없어진다.
    - 리팩토링
        
        : TC 작성 후에, 코드와 클래스를 정리해도 된다. (위 목록의 2,3,4번 내용)
        
        - 리팩토링 단계에서 클린 코드를 위한 모든 방법을 동원한다.
        → 응집도는 높이고, 결합도는 낮추기. 관심사 분리하기. 적절한 네이밍
        & 중복 제거, 개발의도 표현, 클래스와 메서드 최소화하기.

**오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**

- 순수 자바 AOP 프레임워크 내용을 읽던 중, 스프링 빈과 어노테이션을 활용한 예제가 나온다. 코드만 보면 무슨 말인지 알겠는데, 설명을 보면 설명하고자 의도하는 게 뭔지 더 잘 모르겠다.
CS나 개발 이론적인 면에서 많이 부족하기 때문이라고 느낀다. 소스코드는 자주 봐서 구현체로서 아는거지만, 그 밑에 무슨 구조가 깔려있는지 이해하기가 어렵다.
- Aspect J도 자주 본 단어인데, 설명을 보면 무슨뜻인지 도통 이해가 어렵다. 간단한 개념 수준이라도 따로 공부해 봐야겠다.

---

- 사실 ‘창발성’ 이라는 단어 자체가 무슨 뜻인지 몰라서 찾아봤다. 말이 이해가 안될 때는 원서를 보는 것도 괜찮은 것 같다.
- 테스트에 대한 이야기가 나온다. 적절한 테스트케이스의 작성. 다음번엔 본 개발 전에 꼭 고려해서 만들어 봐야겠다.
QA가 있어도, QA는 유저 입장에서 테스트 시나리오를 작성한다. 그것과 별개로 개발 담당자로서 스스로 만든 시스템을 테스트하고 평가하는 기준을 세우는 것도 중요한 역량으로 느껴진다.

**궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

- Proxy vs. Proxy Pattern
    
    : 일반적인 ‘프록시’ 라는 용어와 디자인패턴 ‘프록시패턴’ 은 차이가 있다.
    
    - 일반적으로 부르는 Proxy
    : 실제 Target의 기능을 수행하면서 **기능을 확장하거나 추가하는 실제 "객체"**를 의미한다.
    - Proxy Pattern
    : 실제로 Target에 대한 기능을 확장하거나, 추가하지 않는다. 그저 클라이언트가 타깃에 접근하는 방식을 변경해주는 역할을 한다.
    
    ```java
    public class JdkProxyDemo {
    
        interface If {
            void originalMethod(String s);
        }
    
        static class Original implements If {
            public void originalMethod(String s) {
                System.out.println(s);
            }
        }
    
        static class Handler implements InvocationHandler {
            private final If original;
    
            public Handler(If original) {
                this.original = original;
            }
    
            public Object invoke(Object proxy, Method method, Object[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
                System.out.println("BEFORE");
                method.invoke(original, args);
                System.out.println("AFTER");
                return null;
            }
        }
    
        public static void main(String[] args){
            Original original = new Original();
            Handler handler = new Handler(original);
            If f = (If) Proxy.newProxyInstance(
                    If.class.getClassLoader(),
                    new Class[] { If.class },
                    handler);
            f.originalMethod("Hallo");
        }
    
    }
    ```
    
    - Invocation Handler : invoke만 구현!
    - **동적으로 생성된 프록시 클래스는 인터페이스를 구현한다.**
    - 프록시하려는 클래스가 인터페이스의 구현체가 아니라면, CGLIB 등의 바이트코드 라이브러리 사용하기.
- ABSTRACT FACTORY pattern
    - 팩토리 메서드 패턴
        - 조건에 따른 객체 생성을 팩토리 클래스로 위임하여, 팩토르 클래스에서 객체를 생성하는 패턴
    - 추상 팩토리 패턴
        - 서로 관련이 있는 객체들을 통째로 묶어서 팩토리 클래스로 만들고, 이들 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴
- fetch = fetchType.EAGER
    - 지연 로딩 LAZY
        - 로딩되는 시점에 Lazy 로딩 설정이 되어있는 엔티티는 프록시 객체로 가져온다.
    - 즉시 로딩, EAGER
        - SQL을 한번에 즉시 조회. 실행 결과를 보면 객체도 프록시 객체가 아니라 실제 객체.
        - @ManyToOne, @OneToOne과 같이 @XXXToOne 어노테이션들은 기본이 즉시 로딩(EAGER) 이다.
    - 실무에서는 가급적 지연 로딩만 사용한다. 즉시 로딩 쓰지 말자.