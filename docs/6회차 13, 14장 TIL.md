# 6회차. 13, 14장 TIL

담당자: Jieun Ryu
상태: 완료

**TIL (Today I Learned)**

2022.05.30

**오늘 읽은 범위**

13장. 동시성 / 14장. 점진적인 개선

**책에서 기억하고 싶은 내용을 써보세요.**

- 13장. 동시성
    
    > 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
    > 
    
    ### 동시성이란?
    
    : 결합을 없애는 전략 → 무엇 / 언제를 분리하는 전략
    
    - 무엇 / 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
    - ex) 서블릿 관리 → 컨테이너들은 동시성을 “부분적으로” 관리하며, 
    원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.
    
    ### 동시성에 관한 잘못된 관점들
    
    1. 동시성은 “항상” 성능을 높여준다? ⇒ “때로” 성능을 높여준다.
        
        → 대기 시간이 아주 길어, 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적이 충분이 많은 경우에만 성능이 높아진다.
        
    2. 동시성을 구현해도 설계는 “변하지 않는다”? ⇒ 싱글/멀티스레드는 설계가 판이하게 다르다.
    3. 웹 or EJB 컨테이너를 사용하면 동시성을 이해할 필요가 “없다”?
    ⇒ 동시 수정, 데드락 등의 문제를 피하기 위해 꼭 알아야 한다.
    
    ### 동시성 방어 원칙
    
    <aside>
    💡 1. 동시성 관련 코드는 다른 코드와 분리할 것
    
    2. 자료를 캡슐화하고, 공유 자료를 최대한 줄일 것.
      독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록,
      자료를 독립적인 단위로 분할하여 설계할 것.
    
    4. 언어에서 자체 제공하는 클래스를 검토할 것. ex) java.util.concurrent
    
    5. 공유객체 하나에는 가급적 메서드 하나만 이용하기.
      한 공유 객체에 여러 메서드가 필요한 경우, 여러 측면의 잠금 기법을 고려해야 한다.
    6. 동기화하는 부분을 최대한 작게 만든다. ( = 임계영역 수를 최소화)
    
    7. 스레드 종료 코드는 개발 초기부터 고민하고 동작하도록 “초기부터” 구현하자.
    
    8. 문제를 노출하는 TC를 작성하라. 그리고 자주 수행해라. 
      테스트 실패시 절대로 그냥 지나치치 말고 원인을 분석해라.
    
    9. 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 분리하기.
    
    </aside>
    
    1. SRP, 단일 책임 원칙
        
        : 동시성은 “복잡성” 이라는 이유 하나만으로 코드를 분리할 이유가 충분하다.
        
    2. corollary, 자료 범위를 제한하기.
        
        : 공유 객체 = 임계영역은 synchronized 키워드로 보호.
        
        → 임계영역의 수를 줄이는 기술이 필요함. 자료 캡슐화 및 공유자료 최소화.
        
        2-1) 자료 사본을 사용하기.
        
        : 공유 자본을 줄이려면, 처음부터 공유하지 않는 방법이 best.
        
        사본으로 동기화를 피할 수 있다면, 내부 잠금보다 더 적은 비용으로 위험 회피 가능.
        
        2-2) 스레드는 가능한 독립적으로 구현하기.
        
        : 각 스레드는 요청 하나를 처리한다. 모든 정보는 비공유 출처에서 가져오며, 로컬 변수에 저장하면 다른 스레드와 동기화가 불필요하다.
        
    3. 라이브러리 이해하기 (Thread-safe libs)
        
        3-1) Thread-safe 컬렉션 사용하기.
        
        3-2) 서로 부관한 작업을 수행할 떄는 executor 프레임워크를 사용한다.
        
        3-3) 가능한 스레드가 blocking 되지 않는 방법을 사용하기
        
        3-4) 일부 클래스 라이브러리는 스레드에 안전하지 못하다!
        
        - 자바 스레드 관련 라이브러리?
            1. ConcurrentHashMap
            2. ReenterantLock
                
                : synchronized와 비슷하지만, lock 획득 시점과 해제 시점을 지정 가능!
                
            3. Semaphore
                
                : count 갯수가 있는 lock
                
            4. CountDownLatch
                
                : 지정 수만큼 이벤트 발생 후에 대기중인 스레드를 모두 해제한다. 모든 스레드에게 동시에 공평하게 시작할 기회를 준다.
                
    4. 실행 모델 이해하기
        - 멀티스레드 환경 구성에 꼭 고려할 요소들.
            1. 한정된 자원 
                
                : 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적. ex) DB connection, I/O buffer
                
            2. 상호 배체
                
                : 한번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우. ex) 멜론 스트리밍, 은행거래 등
                
            3. 기아상태
                
                : 스레드가 지나치게 오랜 시간 or 영원히 자원을 기다리는 상태.
                ex) 항상 우선순위가 최하위인 스레드면, 우선순위 스레드 이벤트가 끊임없이 발생하는 경우 최하위 스레드는 기아상태에 빠지게 된다.
                
            4. 데드락
                
                : 여러 스레드가 서로가 끝나기를 기다리는 상태. 모든 스레드가 필요한 자원을 다른 스레드가 점유하고 풀어주지 않으면 어느 쪽도 진행하지 못함.
                
            5. 라이브락
                
                : 락을 거는 단계에서 스레드가 서로를 방해하게 되어, 스레드는 계속 진행을 시도하나 공명으로 인해 영원히 진행불가 상태에 빠짐.
                
        
        4-1) 생산자 ↔ 소비자 관계.
        
        : 생산자 스레드 → 대기열 queue (한정 자원) → 소비자 스레드
        시그널이 엉키면, 큐에 실행 가능한 자원들이 있음에도 불구하고 서로의 신호만을 기다릴 수 있다.
        
        4-2) 읽기 - 쓰기
        
        : 스레드 처리율 문제. I/O 처리에서 발생하기 쉽다.
        
        대부분 읽기 처리가 쓰기보다 빠른데, 처리율을 강조하면 쓰기는 기아상태에 빠지고,
        쓰기가 우선권을 가지면 처리율이 떨어지므로 균형점 모색 필요.
        
    5. 동기화 메서드 간의 의존성 이해하기
        
        → 공유객체 하나에는 메서드 하나만 이용하는 것이 좋으나, 한 객체에 여러 메서드가 필요한 경우에는 다음 측면의 lock을 고려해야 한다.
        
        5-1) 클라이언트에서 잠금 
        
        : 클라이언트에서 첫번째 메소드를 호출하기 전에, 서버를 잠근다. 마지막 메서를 호출할 때까지 잠금을 유지한다.
        
        5-2) 서버에서 잠금
        
        : 서버에다 “서버를 잠그고, 모든 메서드를 호출한 뒤에 잠금을 해제” 하는 메서드를 구현한다. 클라이언트는 이제 해당 메서드를 호출하게 한다.
        
        5-3) 연결서버 (Adapter)
        
        : 잠금을 수행하는 중간 단계를 생성한다. ‘서버에서 잠금’ 방식과 유사하지만, 원래 서버는 변경하지 않는다.
        
    6. 동기화하는 부분을 작게 만들기
    7. 올바른 종료코드는 구현하기 힘들다!
        
        : 스레드를 깔끔하게 종료시키는 코드는 구현하기 힘들다. 대표적 예시가 데드락.
        
        따라서, 스레드 종료 코드는 개발 초기부터 고민하고 동작하도록 “초기부터” 구현하자.
        생각보다 오래 걸리므로, 이미 나온 알고리즘을 적극 활용해 보자.
        
    8. 스레드 코드 테스트하기
        
        : TC를 작성하고 최대한 많이, 다양한 환경에서 돌려볼 것.
        멀티스레드 환경에서는 ‘다시 돌리니까 되더라’ 하고 넘어가면 안 된다!
        
        8-1) 말이 안 되는 실패는 잠정적인 스레드 문제로 취급해야 한다.
        
        : 시스템 실패를 “일회성” 으로 치부하면 안 된다.
        
        8-2) 스레드와 관련없는 순차 코드, POJO 코드부터 제대로 돌게 만들자.
        
        : POJO는 스레드를 모른다. 따라서 스레드 환경 밖에서 테스트가 가능하다. 
        POJO에 넣는 코드는 많을수록 더 좋다.
        
        → 스레드 환경 밖에서 생기는 버그와, 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라.
        
        8-3) 다양한 환경에 쉽게 끼워넣을 수 있도록 코드를 구현하라.
        
        8-4) 스레드를 상황에 맞게 조율할 수 있도록 작성하라.
        
        8-5) 프로세서 수보다 많은 스레드를 돌려봐라.
        
        : 스와핑이 잦을수록, 임계영역을 놓친 코드나 데드락 코드를 찾기 쉬워진다.
        
        8-6) 보조 코드로 스레드 실행순서 흔들기.
        
        : wait, sleep, yield, priority 등의 메서드를 랜덤 실행하는 테스트클래스를 생성 (운영 환경은 no action으로 두면 하나하나 찾지 않아도 코드분리가 쉬워진다.)
        
        실행 순서를 뒤흔들어 스레드 에러를 찾아낼 것.
        

---

- 14장. 점진적인 개선
    - 리팩토링 이전 1차 초안 코드를 가지고 직접 리팩토링 패보고,
    예제대로 다시 해보는 것도 좋은 방법일 것 같다.
    - 깨끗한 코드는 처음부터 나오지 않는다.
        - 꺠끗한 코드의 프로그램을 만들기 위해, 먼저 지저분한 코드를 짠 뒤에 정리해야 한다.
        - 1차 초안 → 2차 초안 → … → 최종 버전
        위와 같은 단계로, “단계적 개선” 을 해 나가야 한다.
    - 프로그램을 망치는 가장 좋은 길 : 개선이라는 이름하에 프로그램 구조를 크게 뒤집는 것!

**오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**

- 스레드에 관한 공부는 언제고 해야하는데.. 하는 마음의 짐처럼 남아있던 영역인데, 회사에서 서버를 만들면서 강제로 빠른시간 안에 구현하다 보니 주입식 교육처럼 이해없이 암기과목으로 머리에 쑤셔넣어진 느낌이다.
- 물론 아직도 내가 맞게 구현했는지, 발견 못한 오류는 뭔지 전혀 모르겠다. 내가 어떤 건 적절하게 고려해서 구현했고, 어떤건 놓치고 개발을 한 걸까?
- 일부 클래스는 멀티스레드에 안전하지 못하다는 내용이 놀랍다. 자바에서 기본 제공하는 클래스는 무의식적으로 그냥, 원래 있는거니까.. 하고 사용하기 쉽다. 마치 int a = 0; 선언하는 것처럼.
나도 SimpleDateFormat이 멀티스레드 안정성을 제공하지 않는다는 걸 몰랐고, ReenterantLock 관련 포스팅을 보다가 글쓴이가 글 끄트머리에 지나가듯 언급한 걸 보지 못했더라면, 그걸 보고 한번 찾아볼까 생각하지 않았더라면 아무런 고려 없이 사용했을 것이다.
- 위 내용을 알기 위해서라도, 테스트코드와 멀티스레딩의 경우 부하 테스트가 꼭 필요하다고 생각하게 됐다. 테스트 코드의 중요성!
- 책에서 언급된 것 중, 이번 서버개발에 고려해서 넣은 사항
    1. synchronized의 사용 
        
        → 의도적으로 포스 사용 배제하였으며 따로 connection pool을 구현해 사용했다. 하나의 스레드에서 커넥션을 하나 꺼내갈 때, 무조건 커넥션 상황이 동기화 되도록.
        connection pool을 공유자원화 및 싱글톤으로 구현.
        
        ```java
        private final int maxPoolSize = Config.getMariaPoolSize();
        private int connNum = 0;
        private static final String SQL_VERIFYCONN = "SELECT 1";
        Stack<Connection> freePool = new Stack<>();
        Set<Connection> occupiedPool = new HashSet<>();
        
        // 1. Singleton - lazy holder 
        private MariaConnPool(){}
        
        private static class Holder {
              private static final MariaConnPool instance = new MariaConnPool();
        }
        
        public static MariaConnPool getInstance() {
            return Holder.instance;
        }
        
        // 2. Connection synchronized
        // 2-1. public으로 오픈한 메서드는 getConnection, returnConnection 두 메서드 뿐이며
        // 나머지는 모두 private으로 내부 호출함.
        
        //synchronized getConnection 예시
        public synchronized Connection getConnection() throws Exception {
            Connection conn;
        
        // config에서 설정한 connection pool 갯수만큼만 대기 큐에서 꺼내 사용할 수 있음.
        // 현재 모두 사용중인 경우, 사용가능한 connection 리턴될때까지 queue full 여부 체크
            while(isFull()){  
                Thread.sleep(500);
            }
        
            conn = getConnectionFromPool();
        
            // If there is no free connection, create a new one.
            if (conn == null) {
                conn = createNewConnectionForPool();
            }
        
            conn = makeAvailable(conn);
            return conn;
        }
        ```
        
    2. non thread-safe 라이브러리 :  SimpleDateFormat
        
        : 다른 라이브러리로 대체하거나 thread-safe 한 방법으로 사용하거나.. 둘 중, 후자를 선택했으며, 아래와 같이 사용함
        
        ```java
        private static SimpleDateFormat sdf;
        
        private synchronized static SimpleDateFormat getSdf(){
        		if(sdf == null){
        			sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ");
        			sdf.setTimeZone(TimeZone.getDefault());
        		}
        		return sdf;
        	}
        ```
        
    3. ReenterantLock
        
        →  tryLock을 사용해 DB 무결성이 꼭 지켜져야 하는 필수 로직에 한번에 한 task만 실행할 수 있도록 처리함.
        
        ```java
        MariaConnPool connPool = MariaConnPool.getInstance();
                Connection conn = null;
                try {
                    if(locker.tryLock(10, TimeUnit.MINUTES)){
                        conn = connPool.getConnection();
                        conn.setAutoCommit(false);
        
                        task.setParameters(conn, collection, dbIdx, curDate);
                        task.run();
                    }
                } catch (Exception e) {
                    throw new Exception("\t["+dbIdx+"] TASK waits to be executable >>>> "+e.getMessage());
                } finally {
                    connPool.returnConnection(conn);
                    locker.unlock();
                }
        ```
        

---

- 처음부터 깨끗한 코드는 나오지 않는다는걸 알면서도, 마음이 조급해서인지 처음부터 잘 짜놓고 싶은 욕심이 앞서간다.
지금 돌아가게만 해 놓으면, 회사 일 하면서 “점진적인 개선” 을 할 시간이 절대 없을거라고 생각해서 그런것 같기도 하고, 내가봐도 엉망인 코드를 공개하기 싫은 마음도 큰 것 같다.
”처음에는 돌아만 가는 엉망인 코드를 써도 괜찮다. 처음부터 좋은 결과물은 없다.”
스스로 저 벽을 깨는게 쉽지 않을 것 같지만, 초안부터 서로 의견을 나눌 수 있어야 코드리뷰 혹은 개발자들과 여러 의견을 나누는 데에 더 여러 방면에서 나은 방향을 찾는 의미가 있지 않을까 싶다.
- 확실히, 진행단계별 테스트 코드가 잘 짜여져 있으면 다음 스텝을 생각하는 데에 훨씬 부담감이 덜해질 것 같다. 책에서 여러번 강조하다시피, 개선의 시작점 = 테스트코드라고 생각하게 된다.

**궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**