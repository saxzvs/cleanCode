# 2회차. 3, 7장 TIL

담당자: Jieun Ryu
상태: 완료

**TIL (Today I Learned)**

2022.05.08

**오늘 읽은 범위**

3장. 함수 / 7장. 오류 처리

**책에서 기억하고 싶은 내용을 써보세요.**

- 3장. 함수를 만드는 방법
    1. 가능한 작게 만들기.
        1. 중첩 구조가 생길 만큼 커져서는 안 된다.
    2. 한 가지만 해라!
        1. 추상화 수준이 한 단계. 의미 있는 이름으로 다른 함수를 추출할 수 없도록.
        2. 함수 당 추상화 수준은 하나로 통일하기.
            1. 한 함수 내에서 다양한 추상화 수준의 동작을 하면, 읽는 사람이 편하게 분석이 될까?
    3. Switch (if-else도 동일.) *생각해 볼 것: if-else vs switch. 어떤 것이 합리적?
        
        ⇒ 적절한 추상화 작업으로 동일 구조 무한생성 피하기!
        
    4. 서술적인 네이밍 (객체 혹은 메소드명이 길어지는 데에 두려움 버리기!)
    5. 인수는 0개가 best! 0>1>2.... 3개 이상은 피할 것.
        
        → 모든 인수에 적합한 유형을 고려한 TC 작성도 힘들어진다.
        
        1. 단항 형식 
        ex) 이벤트 : only args, no return.
        변환 함수라면 리턴으로 돌려주기! (단순 이벤트와 구분하기)
        2. 플래그 인수 → 가급적 피할 것!
            
            → 한 함수에서 여러 작업을 한다고 공표하는 셈. 플래그에 따라 “함수 분리” 로 처리하는게 바람직
            
    6. No side effect!
        1. 부수효과를 모르는 채로 다른 함수에서 호출하게 되면?
    7. 명령과 조회는 분리시킬 것
        1. do something / read something → 한번에 하지 말자. “하나의 동작” 만을 수행하기.
    8. 오류 코드나 플래그보다는 예외처리로 처리하는 것이 바람직함.
    9. try-catch 구문 뽑아내기 * 다시 읽어볼 것. pdf) 94
    10. 중복 금지 (추상화 단계가 적절하게 이루어져 있으면, 중복코드 발생이 현저히 줄어들지 않을까?)
    
    - 궁금한 점: abstract class를 실제 사용해본 경험?
    단순 i/f만으로는 원하는 추상화 단계를 얻기 힘든일도 많을 것 같은데..
- 7장. 오류 처리
    1. 미확인 예외 사용하기.
        1. 하위 → ... → 최상위까지 모든 catch or throw 절을 수정할 것인가?
    2. 예외처리에도 의미를 두기.
        1. 적절한 감싸기 필요. 외부 라이브러리-프로그램간 의존성을 최소화.
    3. 정상 흐름 정의하기
        1. 특수 사례 패턴 활용하기. 굳이 예외처리로 잡아야 할 상황이 없는 게 제일 좋지 않을까?
    4. null 반환 금지. 호출자에게 문제를 떠넘기는 코드
    5. null 전달도 금지.
    
    ⇒ 4, 5 사례 모두 caller / callee에게 NPE 문제를 떠넘기는 나쁜 습관.
    
    - 궁금한 점: 실제 잘 짜여진 코드에서는 어느 정도로 예외수준을 분류할까?

**오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**

- 좋은 함수를 짠다는 게, 굉장히 고려할 점이 많은 어려운 작업이라고 다시한 번 생각하게 됐다.
당장 필요한 기능을 구현하는 데에 급급해서 많은 점을 놓치고 있었던 것 같다.
책 전반에 걸쳐 가장 강조하는 개념이라고 생각되는 “추상화” 라는 과정을 평소 프로그램을 구현할 때 어느정도 고려하고 있을까?
실제 추상화가 적절히 이루어진 예시 코드를 보면서 공부할 기회가 더 많았으면 좋았을 텐데.. 싶다. → 이래서 이직하고 싶기도 하다 ㅠㅠ
- 추상화는 실제 어느 단계에서 이루어지는게 적절할까? 설계 / 구현 / 테스트 및 리팩토링 전반에 걸쳐서 이루어지면 되는 걸까?
추상화가 전혀 고려되지 않은 프로그램을 테스트 단계에서 고려해서 코드를 다시 분류하는 건 현실적으로 힘들지 않을까.. 싶다.
가장 좋은건 설계 단계에서겠지만, 아직은 첫 단계부터 적절한 추상화 단계를 떠올리기가 쉽지 않다. 내 개발 실력이 그만큼 부족해서겠지만.
- 예외처리도 어느 수준까지 분류해야 하는지 구분이 조금 어렵다.
예외처리 내용에 꼭 차이가 있어야 하는 경우가 아니라면 그동안은 무조건 Exception으로 통쨰로 던졌는데, 세세한 예외 처리는 어느 단계에서 필요한 걸까?
- “특수 사례 패턴” 내용이 좋다고 생각했지만 아직 실무에서 직접 사용하는 것을 본적은 없는 것 같다. 사이드 프로젝트에서 해당 내용을 고려해서 코드를 한 번 짜볼 기회가 있으면 좋겠다.
- 전반적으로 오늘 내용은 내가 그동안 코드를 짤 때 고려하지 않았던 내용들이 많았다. 그래서 저번 주보다 이해하는 데에도 시간이 좀 더 걸렸고(이해하지 못한 부분도 많다.) 내가 어떤 부분이 부족하고 또 어떤 면에서 좋은 코드를 더 보고 배워야 하는지도 감이 조금 오는 것 같다.
문제는, 그런 좋은 코드를 어디에서 찾느냐...?

**궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

- 다섯 가지 애자일 원칙 (SOLID 원칙)
    - 단일 책임(SRP; Single Responsibility)
    - 개방/폐쇄(Open/Close)
    - 리스코프 치환(Liskov's Substitution)
    - 인터페이스 분리(Interface Segregation)
    - 의존성 주입(Dependency Inversion)
- SRP (Single Responsibility Principle)
    - 하나의 객체는 반드시 한 동작만의 책임을 가진다.
        - 하나의 객체가 여러 동작을 맡게 된다면? 프로그램에서 해당 객체에 대한 의존성이 너무 커지는 문제 발생 (수정할떄도 해당 객체를 사용하는 모든 영역에 테스트 필요)
        - 필요한 객체 내용을 추상화한 후, 추상화 객체를 사용하는 각 객체에서 자기에게 필요한 역할만 구현해 사용하면 하나의 객체에는 하나의 책임만 가질 수 있도록 설계할 수 있음.
        - 참고 포스팅
        
        [[OOP] 객체지향 5원칙(SOLID) - 단일 책임 원칙 (Single Responsibility Principle) - 𝝅번째 알파카의 개발 낙서장](https://blog.itcode.dev/posts/2021/08/13/single-responsibility-principle)
        
- OCP (Open Closed Principle)
    - 애자일 원칙 중 하나로, 기능 추가/변경은 가능하지만 기존 소스코드에는 영향을 주지 않아야 함.
    - **개방-폐쇄 원칙**
    (OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다'는 프로그래밍 원칙
        - 수정에 대해서 닫혀 있다?
            - 특정 행위를 인터페이스화 (추상화) 하여, 해당 인터페이스를 구현한 어떤 클래스든 원하는 객체를 주입하여 활용 가능.
            - 즉, 특정 객체를 주입하는 데에 별도의 소스 수정이 필요하지 않다.
        - 확장에 대해 열려 있다?
            - I/F를 구현한 클래스를 언제든 활용할 수 있는 확장성 확보.
            - 즉, 추상화한 I/F 외부에서 객체를 주입하기만 하면 얼마든지 사용이 가능함.
    - 참고 서적: 토비의 스프링